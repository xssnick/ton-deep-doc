## Overlay network

Архитектура тона построена таким образом, что в ней могут существовать одновременно и независимо очень много чеинов - они могут быть как приватные, так и публичные. 
Ноды имеют возможность выбирать, данные каких шардов и чеинов им хранить и обрабатывать. 
При этом протокол обмена данными остается неизменным засчет универсальности. Этого достичь позволяют такие технологии, как DHT, RLDP и оверлеи. 
С первыми двумя мы уже знакомы, в этом разделе познакомимся с оверлеями.

Оверлеи отвечают за разделение единой сети на дополнительные суб-сети. Оверлеи могут быть как публичные, к которым может подключиться любой, так и приватные, куда для вступления нужны дополнительные данные, известные только определенному кругу лиц. 

Все чеины в тоне, включая мастерчеин, обмениваются данными, используя свой оверлей. 
Чтобы вступить в него, нужно найти ноды, которые уже состоят в нем, и начать с ними обмен данными. 
Найти ноды можно с помощью DHT. 


### Взаимодействие с другими нодами оверлея

Мы уже разбирали пример с поиском нод оверлея в статье про DHT, 
в разделе [Поиск нод, хранящих состояние блокчеина](https://github.com/xssnick/ton-deep-doc/blob/master/DHT.md#%D0%BF%D0%BE%D0%B8%D1%81%D0%BA-%D0%BD%D0%BE%D0%B4-%D1%85%D1%80%D0%B0%D0%BD%D1%8F%D1%89%D0%B8%D1%85-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5-%D0%B1%D0%BB%D0%BE%D0%BA%D1%87%D0%B5%D0%B8%D0%BD%D0%B0). В этом разделе сконцентрируемся на взаимодействии с ними.

При запросе в DHT, мы получим адреса нод оверлея, у которых сможем узнать адреса других нод этого оверлея c помощью [overlay.getRandomPeers](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L237). 
После того, как мы подключимся к достаточному количеству нод, мы сможем получать от них всю информацию о блоках и другие события чеина, а также отправлять им на обработку наши транзакции. 

#### Найдем побольше соседей

Разберем пример с получением нод в оверлее.

Для этого отправим запрос `overlay.getRandomPeers`, сериализуем TL схему:
```
overlay.node id:PublicKey overlay:int256 version:int signature:bytes = overlay.Node;
overlay.nodes nodes:(vector overlay.node) = overlay.Nodes;

overlay.getRandomPeers peers:overlay.nodes = overlay.Nodes;
```
`peers` - должны содержать известных нам пиров, чтобы не получить их же обратно, но так как мы пока никого не знаем, `peers.nodes` будет пустым массивом.

Каждый запрос внутри оверлея должен иметь перфикс в виде TL схемы:
```
overlay.query overlay:int256 = True;
```
В качестве `overlay` должен быть айди оверлея - айди ключа от схемы `tonNode.ShardPublicOverlayId` - тот же, что мы использовали для поиска в DHT.

Нам нужно объединить 2 сериализованные схемы, просто соединив 2 массива байтов, `overlay.query` будет идти первым, `overlay.getRandomPeers` - вторым.

Полученный массив мы оборачиваем в схему `adnl.message.query` и отправляем по ADNL. В ответ мы ждем `overlay.nodes` - это будет список нод оверлея, к которым мы можем подключиться и, если нужно, повторить тот же запрос уже к ним, пока мы не наберем достаточное количество соединений.

#### Функциональные запросы

После установки соединения, мы можем обращаться к нодам оверлея с [запросами](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L413) `tonNode.*`.

Для запросов такого рода используется протокол RLDP. И важно не забыть про префикс `overlay.query` - он должен использоваться для каждого запроса в оверлее.

В самих запросах нет ничего необычного, они очень похожи на то, что мы делали в статье про ADNL TCP. 

Например, в запросе `downloadBlockFull` используется уже знакомый нам айди блока:
```
tonNode.downloadBlockFull block:tonNode.blockIdExt = tonNode.DataFull;
```
Передав его, мы сможем скачать полную информацию о блоке, в ответ получим:
```
tonNode.dataFull id:tonNode.blockIdExt proof:bytes block:bytes is_link:Bool = tonNode.DataFull;
  или
tonNode.dataFullEmpty = tonNode.DataFull;
```
В случае наличия, в поле `block` будут данные в формате TL-B. 

Таким образом мы можем получать информацию напрямую от нод.
